function net = Tree2FFNN(Tree)

WL_Tree = Tree;       %%%% We make a copy of the Tree because we want to replace its 'min' and 'max' with their corresponding FFNNs.
Dists_kids = Tree;    %%%% We also make another copy to replace its 'min' and 'max' with distance of them from the root.
n = nnodes(Tree);     %%%% reurns the number of nodes in the tree.

IDs = depthfirstiterator(Tree, 1, false);   %%% sorts the id of the nodes based on the DFS traversal


for i = 1:n
    if ~isleaf(Tree,IDs(i))
        num_inputs = length(getchildren(Tree,IDs(i)));  
        if strcmp(get(Tree,IDs(i)),'and')
            type = 'min';   %%% we are reading the Tree, once we face the 'and' operator then we replace it with min FFNN. 
        elseif strcmp(get(Tree,IDs(i)),'or')
            type = 'max';   %%% we are reading the Tree, once we face the 'or' operator then we replace it with max FFNN.
        end
        [Weights, layers] = pure_poslin(type, num_inputs);   %%% this functions gets the number of elements that are supposed to get involved in 'min' or 'max' and generates the 
                                                             %%% the corresponding FFNN
        height = length(layers);     %%% height is the depth of the FFNN generated by the pure_poslin layer
        WL_Tree = set(WL_Tree,IDs(i),{Weights, layers});    %%%% We are filling the WL_Tree with computed weights and layers.
        Dists_kids = set(Dists_kids,IDs(i),height);    %%% shows the distance of the kids from their parents. We know parents are only 'min' or 'max' characters, once they are 
                                                     %%% replaced with FFNNs then the depth of the FFNN is distance between the kidsand parents
    end
end
clc

for i=1:n
    h{IDs(i)} = Dist_to_root(Dists_kids,IDs(i));  %%% computes the distance of a node from the root. This distance is the number of all the ReLU layers in between.
end
H = max([h{:}]);   %%% when we comuted all of the h, then apparently the maximum h is the depth of the STL-FFNN 



%%% In the following for loop we construct WL_tree and another tree which
%%% is called Dists_kids, these trees are introduced before
for i = 1:n
    if isleaf(Tree,IDs(i))
        clear Weights layers
        for j = 1:H-h{IDs(i)}
            Weights{j} = 1;
            layers{j} = {'purelin'};
        end
        if h{IDs(i)}<H
            Weights{H-h{IDs(i)}+1} = 1;
            WL_Tree = set(WL_Tree,IDs(i),{Weights, layers});
            Dists_kids = set(Dists_kids,IDs(i),H-h{IDs(i)});
        else
            Weights = [];
            layers = [];
            WL_Tree = set(WL_Tree,IDs(i),{Weights, layers});
            Dists_kids = set(Dists_kids,IDs(i),0);
        end
    end
end
clc

%%%  for any distance i from top it returns the layer and its
%%%  corresponding upside weight matrix
%%%  Use{} is the main idea of this code , it claims if the nodes are
%%%  labeled with DFS traversal then for sure the next involved is really
%%%  the next participent no later and no previous. It is exactly the next.
clear Use W L
for i = 1:H
    Use{i} = [];
    W{H-i+2} = [];
    L{H-i+1} = [];
    for j = 1:n
        if h{IDs(j)}<i 
            if isleaf(Dists_kids,IDs(j))
                Use{i} = [Use{i}, IDs(j)];
            else
                children=getchildren(Dists_kids, IDs(j));
                if h{children(1)}>=i
                    Use{i} = [Use{i}, IDs(j)];
                end
            end
        end
    end
    
    clear Add W_add L_add
    for j = 1:length(Use{i})
        Add = get(WL_Tree, Use{i}(j));
        W_add = Add{1};
        L_add = Add{2};
        hp = get(Dists_kids, Use{i}(j));
        dist2root = h{Use{i}(j)};
        
        
        
        if i==h{Use{i}(j)}+1
            
            kids = getchildren(Dists_kids, getparent(Dists_kids, Use{i}(j)));
            num_kids = length(kids);
            index = find(kids==Use{i}(j));
            if index<num_kids
                if mod(index,2)==0   %%% when we are facing our siblings if we locate at an even position we need to combine with the previous odd one
                    X=[1;-1;-1; 1]*W_add{end};
                    Diff_zero = size(W{H-i+2},1)-size(X,1);
                    W{H-i+2} = sparse([W{H-i+2} , [zeros(Diff_zero,size(X,2));X]  ]);
                else                 %%% when we are facing our siblings if we locate at an odd position we need to combine with the next even one thus we are treated now as independent
                    W{H-i+2} = sparse(blkdiag(W{H-i+2} , [1;-1; 1;-1]*W_add{end}));
                end
            elseif index==num_kids
                if mod(index,2)==0   %%% when we are facing our siblings if we locate at an even position we need to combine with the previous odd one
                    X=[1;-1;-1; 1]*W_add{end};
                    Diff_zero = size(W{H-i+2},1)-size(X,1);
                    W{H-i+2} = sparse([W{H-i+2} , [zeros(Diff_zero,size(X,2));X]  ]);
                else                 %%% although there is no next even one but we are still independent as we want to pick up a purelin an be independent
                    W{H-i+2} = sparse(blkdiag(W{H-i+2} , 1*W_add{end}));
                end
            end
            
        else
            W{H-i+2} = sparse(blkdiag(W{H-i+2}, W_add{hp+dist2root-i+2}));
        end
        L{H-i+1} = [L{H-i+1}; L_add{hp+dist2root-i+1}];   %%% if you start from 10 and come down 5 times you face index 6 not 5
    end
end
W{1} = [];
clear Add W_add L_add
for j = 1:length(Use{H})
    Add = get(WL_Tree, Use{H}(j));
    W_add = Add{1};
    hp = get(Dists_kids, Use{H}(j));
    dist2root = h{Use{H}(j)};
    W{1} = sparse(blkdiag(W{1}, W_add{1}));
end


net.weights = W;
net.layers = L;

end






function H = Dist_to_root(Dists_kids, i)  %%% returns the  number of layers we face from i to the root
if i==1
    H = 0;
else
    H = 0;
    father = i;
    while father~=1
        father = getparent(Dists_kids,father);
        H = H+get(Dists_kids, father);
    end
end
end
